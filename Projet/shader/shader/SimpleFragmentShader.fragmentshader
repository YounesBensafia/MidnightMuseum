#version 330 core

in vec3 Vcolor;
in vec3 vPos;
in vec3 vNormal;
in vec2 vTexture;

out vec4 color;

uniform vec3 lightColor;
uniform vec3 lightPos[9]; 
uniform int numLights;    
uniform vec3 viewPos;
uniform sampler2D ourTexture;
uniform int useTexture; 
uniform vec3 materialColor; 

// Spotlight (flashlight)
uniform vec3 spotLightPos;
uniform vec3 spotLightDir;
uniform int spotLightOn;

void main()
{
    vec4 baseColor;
    if (useTexture == 1) {
        baseColor = texture(ourTexture, vTexture);
    } else {
        baseColor = vec4(materialColor, 1.0);
    }
    
    float ambientIntens = 0.05;
    vec3 ambient = lightColor * ambientIntens;
    
    vec3 totalDiffuse = vec3(0.0);
    vec3 totalSpecular = vec3(0.0);
    vec3 normal = normalize(vNormal);
    vec3 viewDir = normalize(viewPos - vPos);
    
    for (int i = 0; i < numLights; i++) {
        vec3 lightDir = normalize(lightPos[i] - vPos);
        float distance = length(lightPos[i] - vPos);
        
        // --- SETTINGS ---
        float strengthBoost = 1.0;
        float cutOffDeg = 25.0;
        float outerCutOffDeg = 40.0;
        float specPower = 32.0;       
        float specIntensMultiplier = 0.5;
        vec3 currentLightColor = lightColor;
        bool isPointLight = false; 

        // Wall Lamps Logic (Indices 3, 4, 5)
        if (i >= 3 && i <= 5) { 
            strengthBoost = 1.5;      // Fixed: Restored to 6.0 for paintings
            cutOffDeg = 45.0;       
            outerCutOffDeg = 80.0;  
            currentLightColor = lightColor * vec3(1.0, 0.85, 0.6); 
        }
        
        // --- CHANDELIER LOGIC (Index 6) ---
        float sparkleMask = 1.0; // Default: no masking for spotlights
        if (i == 6) {
            strengthBoost = 0.6;    
            isPointLight = true;    
            currentLightColor = lightColor * vec3(1.0, 0.95, 0.8);
            
            specPower = 128.0; 
            specIntensMultiplier = 2.0; 

            // FIX: Mask the specular so it only appears near the chandelier (within ~5 units)
            // This prevents the distant walls from looking "wet" or shiny.
            sparkleMask = smoothstep(5.0, 1.0, distance); 
        }

        // --- SPOTLIGHT INTENSITY ---
        float spotIntensity;
        if (isPointLight) {
            spotIntensity = 1.0; 
        } else {
            vec3 spotDir = vec3(0.0, -1.0, 0.0); 
            float theta = dot(-lightDir, spotDir); 
            float cutOff = cos(radians(cutOffDeg));      
            float outerCutOff = cos(radians(outerCutOffDeg)); 
            float epsilon = cutOff - outerCutOff;
            spotIntensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
        }
        
        // --- LAMP GLOW ---
        float glowPower = 1.0 / (1.0 + 2.0 * distance * distance); 
        vec3 lampGlow = currentLightColor * 0.5 * glowPower * strengthBoost;

        // --- FINAL CALCULATION ---
        float attenuation;
        if (i == 6) {
            attenuation = 1.0 / (1.0 + 0.01 * distance + 0.002 * distance * distance);
        } else {
            attenuation = 1.0 / (1.0 + 0.04 * distance + 0.01 * distance * distance);
        }
        
        // Diffuse (Walls will still get the soft glow)
        float diff = max(dot(normal, lightDir), 0.0);
        totalDiffuse += (diff * currentLightColor * 2.0 * strengthBoost * attenuation * spotIntensity) + lampGlow;
        
        // Specular (Sparkle logic with distance mask)
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specPower);
        
        // Apply sparkleMask here to kill highlights on distant walls
        totalSpecular += (specIntensMultiplier * strengthBoost * spec * currentLightColor * spotIntensity * sparkleMask) + (lampGlow * 0.2);
    }

    // Flashlight contribution (White light for contrast)
    if (spotLightOn == 1) {
        vec3 lightDir = normalize(spotLightPos - vPos);
        float distance = length(spotLightPos - vPos);
        float theta = dot(lightDir, normalize(-spotLightDir));
        float cutOff = cos(radians(10.0)); 
        float outerCutOff = cos(radians(18.0)); 
        
        if (theta > outerCutOff) {
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            float attenuation = 1.0 / (1.0 + 0.045 * distance + 0.0075 * distance * distance);
            float diff = max(dot(normal, lightDir), 0.0);
            vec3 spotDiffuse = diff * lightColor * 5.0 * intensity * attenuation;
            vec3 reflectDir = reflect(-lightDir, normal);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
            vec3 spotSpecular = 0.5 * spec * lightColor * intensity * attenuation;
            totalDiffuse += spotDiffuse;
            totalSpecular += spotSpecular;
        }
    }
    
    vec3 lighting = ambient + totalDiffuse + totalSpecular;
    vec3 finalColor = lighting * baseColor.rgb;
    color = vec4(finalColor, 1.0);
}